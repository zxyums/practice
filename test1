import React, { useEffect, useMemo } from "react";
import {
  FormHelperText,
  MenuItem,
  Select,
  Tooltip,
  SelectChangeEvent,
} from "@mui/material";
import lodash from "lodash";
import { useController, useFormContext } from "react-hook-form";
import CustomLabel from "./CustomLabel";
import ArrowDropDownIcon from "@mui/icons-material/ArrowDropDown";
import * as styles from "../../shared/styles";
import { FieldConfig } from "../../types/formTypes";
import { FixedSizeList, ListChildComponentProps } from "react-window";

type Props = {
  control: any;
  config: FieldConfig;
  onChange?: (event: SelectChangeEvent<string>, value: string) => void;
};

const CustomSelectField: React.FC<Props> = ({ control, config, onChange }) => {
  const { register, clearErrors } = useFormContext();
  const { fieldState, field } = useController({
    control,
    name: config.name,
    defaultValue: config.defaultValue || "",
    rules: {
      required: config.required ? `${config.label} is required` : false,
    },
  });

  const { error } = fieldState;

  // Clear errors if a valid value is selected
  useEffect(() => {
    if (field.value) {
      clearErrors(config.name);
    }
  }, [field.value, clearErrors, config.name]);

  // Handle `onChange` behavior
  const handleOnChange = (event: SelectChangeEvent<string>) => {
    const selectedValue = event.target.value;
    if (onChange) {
      onChange(event, selectedValue); // Call external onChange prop if provided
    }
    field.onChange(selectedValue); // Default behavior
  };

  // Validate the current value against the dropdown options
  const getValidValue = () => {
    const isValid = config.options?.some(
      (option) => option.value === field.value
    );
    return isValid ? field.value : ""; // Return the valid value or fallback
  };

  // Render the selected value
  const renderValue = (selected: string) => {
    if (!selected) {
      return <span style={styles.fieldEntryStyles}>Select</span>;
    }
    const selectedOption = config.options?.find(
      (option) => option.value === selected
    );
    return selectedOption?.label || selected;
  };

  // Memoized and sorted dropdown options
  const sortedOptions = useMemo(() => {
    if (!Array.isArray(config.options)) {
      console.warn("Dropdown options are missing or invalid");
      return [];
    }
    return lodash.orderBy(config.options, ["value"], ["asc"]);
  }, [config.options]);

  const ITEM_HEIGHT = 40;
  const DROPDOWN_HEIGHT = 300;

  // Virtualized rendering for large dropdown lists
  const renderRow = ({ index, style }: ListChildComponentProps) => {
    const option = sortedOptions[index];
    if (!option) {
      console.warn("Option missing at index:", index);
      return null;
    }
    return (
      <MenuItem key={option.key || option.value} value={option.value} style={style}>
        {option.label || option.value}
      </MenuItem>
    );
  };

  const VirtualizedList = React.forwardRef<HTMLDivElement, any>((props, ref) => (
    <FixedSizeList
      height={DROPDOWN_HEIGHT}
      width="100%"
      itemSize={ITEM_HEIGHT}
      itemCount={sortedOptions.length}
      outerRef={ref as React.Ref<HTMLDivElement>}
      {...props}
    >
      {renderRow}
    </FixedSizeList>
  ));

  // Tooltip-enabled icon
  const IconComponent = (props: any) => (
    <Tooltip title={config.toolTips || ""}>
      <ArrowDropDownIcon {...props} />
    </Tooltip>
  );

  // Determine rendering strategy
  const renderMenuItems = () => {
    if (sortedOptions.length <= 10) {
      // Render as normal MenuItems for small datasets
      return sortedOptions.map((option) => (
        <MenuItem key={option.key || option.value} value={option.value}>
          {option.label || option.value}
        </MenuItem>
      ));
    }

    // Render virtualized list for large datasets
    return null;
  };

  return (
    <div className="flexing">
      <CustomLabel htmlFor={config.name} label={config.label} />
      <Select
        id={config.name}
        value={getValidValue()} // Validate the value
        {...register(config.name)}
        onChange={handleOnChange}
        displayEmpty
        renderValue={renderValue}
        IconComponent={IconComponent}
        inputProps={{
          "data-testid": "custom_select",
          "aria-controls": config.name,
          "aria-label": config.label,
        }}
        MenuProps={
          sortedOptions.length > 10
            ? {
                PaperProps: {
                  style: { maxHeight: DROPDOWN_HEIGHT },
                },
                MenuListProps: {
                  component: VirtualizedList,
                },
              }
            : {}
        }
        disabled={config.readOnly}
        error={!!error}
      >
        {/* Placeholder */}
        <MenuItem value="" disabled>
          <em style={styles.fieldEntryStyles}>Select</em>
        </MenuItem>

        {renderMenuItems()}
      </Select>
      <FormHelperText style={{ color: error ? "#B71C1C" : "#999" }}>
        {error?.message || config.helperText || ""}
      </FormHelperText>
    </div>
  );
};

export default CustomSelectField;
