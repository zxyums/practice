import React, { useEffect, useMemo } from "react";
import {
  FormHelperText,
  MenuItem,
  Select,
  Tooltip,
  SelectChangeEvent,
} from "@mui/material";
import lodash from "lodash";
import { useController, useFormContext } from "react-hook-form";
import CustomLabel from "./CustomLabel";
import ArrowDropDownIcon from "@mui/icons-material/ArrowDropDown";
import * as styles from "../../shared/styles";
import { FieldConfig } from "../../types/formTypes";
import { FixedSizeList, ListChildComponentProps } from "react-window";

type Props = {
  control: any;
  config: FieldConfig;
  onChange?: (
    event: SelectChangeEvent<string>,
    value: string
  ) => void;
};

const CustomSelectField: React.FC<Props> = ({ control, config, onChange }) => {
  const { register, clearErrors } = useFormContext();
  const { fieldState, field } = useController({
    control,
    name: config.name,
    defaultValue: config.defaultValue || "",
    rules: {
      required: config.required
        ? `${config.label} is required`
        : false,
    },
  });

  const { error } = fieldState;

  useEffect(() => {
    if (field.value) {
      clearErrors(config.name);
    }
  }, [field.value, clearErrors, config.name]);

  const handleOnChange = (event: SelectChangeEvent<string>) => {
    const selectedValue = event.target.value;
    if (onChange) {
      onChange(event, selectedValue); // Call separate onChange prop if provided
    }
    field.onChange(selectedValue); // Default behavior
  };

  const getValidValue = () => {
    const isValid = config.options?.some(
      (option) => option.value === field.value
    );
    return isValid ? field.value : ""; // Return valid value or fallback
  };

  const renderValue = (selected: string) => {
    if (!selected) {
      return <span style={styles.fieldEntryStyles}>Select</span>;
    }
    const selectedOption = config.options?.find(
      (option) => option.value === selected
    );
    return selectedOption?.label || selected;
  };

  const sortedOptions = useMemo(() => {
    if (!Array.isArray(config.options) || config.options.length === 0) {
      console.warn("Dropdown options are empty or invalid.");
      return [];
    }
    return lodash.orderBy(config.options, ["value"], ["asc"]);
  }, [config.options]);

  const ITEM_HEIGHT = 40;
  const DROPDOWN_HEIGHT = 300;

  const renderRow = ({ index, style }: ListChildComponentProps) => {
    const option = sortedOptions[index];
    if (!option) return null; // Safeguard against invalid indices
    return (
      <MenuItem
        key={option.key || option.value}
        value={option.value}
        style={style}
      >
        {option.label}
      </MenuItem>
    );
  };

  const VirtualizedList = React.forwardRef<HTMLDivElement, any>((props, ref) => (
    <FixedSizeList
      height={DROPDOWN_HEIGHT}
      width="100%"
      itemSize={ITEM_HEIGHT}
      itemCount={sortedOptions.length}
      outerRef={ref as React.Ref<HTMLDivElement>}
      {...props}
    >
      {renderRow}
    </FixedSizeList>
  ));

  const IconComponent = (props: any) => (
    <Tooltip title={config.toolTips || ""}>
      <ArrowDropDownIcon {...props} />
    </Tooltip>
  );

  return (
    <div className="flexing">
      <CustomLabel htmlFor={config.name} label={config.label} />
      <Select
        id={config.name}
        value={getValidValue()} // Validate the value
        {...register(config.name)}
        onChange={handleOnChange}
        displayEmpty
        renderValue={renderValue}
        IconComponent={IconComponent}
        inputProps={{
          "data-testid": "custom_select",
          "aria-controls": config.name,
          "aria-label": config.label,
        }}
        MenuProps={{
          PaperProps: {
            style: { maxHeight: DROPDOWN_HEIGHT },
          },
          MenuListProps: {
            component: VirtualizedList,
          },
        }}
        disabled={config.readOnly}
        error={!!error}
      >
        {/* Placeholder */}
        <MenuItem value="" disabled>
          <em style={styles.fieldEntryStyles}>Select</em>
        </MenuItem>
      </Select>
      <FormHelperText style={{ color: error ? "#B71C1C" : "#999" }}>
        {error?.message || config.helperText || ""}
      </FormHelperText>
    </div>
  );
};

export default CustomSelectField;