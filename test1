import React, { useCallback, useState } from 'react';
import { Button, Typography, Box } from '@mui/material';
import { useDropzone } from 'react-dropzone';
import * as XLSX from 'xlsx';
import { saveAs } from 'file-saver';

interface GroupHeaderConfig {
  groupName: string;
  headers: { name: string; position: number }[];
}

const REQUIRED_GROUP_HEADERS: { position: number; config: GroupHeaderConfig }[] = [
  { position: 1, config: { groupName: "LOB Details", headers: [
    { name: "INTERNAL USE ONLY", position: 1 },
    { name: "LOB", position: 2 },
    { name: "FLU", position: 3 },
    { name: "FLU LOB / CHANNEL", position: 4 },
    { name: "Email of Associate Completing this template", position: 5 }
  ]}},
  // Add other group headers as needed...
];

const validateHeaders = (groupRow: string[], headerRow: string[]) => {
  for (const { position, config } of REQUIRED_GROUP_HEADERS) {
    if (groupRow[position - 1] !== config.groupName) {
      return { isValid: false, message: `Group name mismatch at position ${position}. Expected: '${config.groupName}'` };
    }
    for (const header of config.headers) {
      if (headerRow[header.position - 1] !== header.name) {
        return { isValid: false, message: `Header mismatch at position ${header.position}. Expected: '${header.name}'` };
      }
    }
  }
  return { isValid: true, message: "File headers are valid and in correct order." };
};

const FileUpload: React.FC = () => {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [validationMessage, setValidationMessage] = useState<string | null>(null);
  const token = 'YOUR_BEARER_TOKEN_HERE';

  const handleAcceptedFiles = useCallback(async (acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    setSelectedFile(file); // Set the file immediately to display it to the user

    if (file.size === 0) {
      setValidationMessage("The file is empty. Please upload a file with content.");
      return;
    }

    const validFileTypes = ['.xlsx', '.xlsm', '.xls'];
    const fileExtension = file.name.split('.').pop()?.toLowerCase();
    if (!validFileTypes.includes(`.${fileExtension}`)) {
      setValidationMessage('Please upload a valid Excel file (.xlsx, .xlsm, .xls)');
      return;
    }

    const fileData = await file.arrayBuffer();
    const workbook = XLSX.read(fileData, { type: 'array' });
    if (workbook.SheetNames.length === 0) {
      setValidationMessage('The file is empty. Please upload a valid Excel file with content.');
      return;
    }

    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
    const sheetData = XLSX.utils.sheet_to_json(firstSheet, { header: 1, blankrows: false }) as string[][];

    // Ensure group headers and main headers exist, then validate
    const groupRow = sheetData[0];
    const headerRow = sheetData[1];

    const { isValid, message } = validateHeaders(groupRow, headerRow);
    if (!isValid) {
      setValidationMessage(message);
      return;
    }

    // Slice off group header and header rows, then filter out any empty rows from the remaining data rows
    const dataRows = sheetData.slice(2).filter(row => row.some(cell => cell !== null && cell !== undefined && cell !== ''));

    if (dataRows.length === 0) {
      setValidationMessage('The file must contain at least one row of non-empty data.');
      return;
    }

    setValidationMessage(null); // Clear validation message if all checks pass
    alert('File is valid and ready for upload.');
  }, []);

  const handleRejectedFiles = useCallback(() => {
    setValidationMessage("The file type or size is not supported. Please upload a valid Excel file.");
  }, []);

  const handleUpload = async () => {
    if (!selectedFile) {
      alert('Please select a valid file first!');
      return;
    }

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      const response = await fetch('/api/v5/excel/upload', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}` },
        body: formData,
      });

      if (!response.ok) throw new Error('Failed to upload file');
      alert('File uploaded successfully!');
    } catch (error) {
      alert('Error uploading file. Please try again.');
    }
  };

  const handleDownload = async () => {
    try {
      const response = await fetch('/api/v5/excel/download', {
        method: 'GET',
        headers: { 'Authorization': `Bearer ${token}` },
      });

      if (!response.ok) throw new Error('Failed to download file');
      const blob = await response.blob();
      const filename = response.headers.get('Content-Disposition')?.split('filename=')[1] || 'downloaded_file.xlsx';
      saveAs(blob, filename);
    } catch (error) {
      alert('Error downloading file. Please try again.');
    }
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDropAccepted: handleAcceptedFiles,
    onDropRejected: handleRejectedFiles,
    accept: {
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
      'application/vnd.ms-excel.sheet.macroEnabled.12': ['.xlsm'],
      'application/vnd.ms-excel': ['.xls']
    },
    maxFiles: 1,
    maxSize: Infinity,
  });

  return (
    <div>
      <Box {...getRootProps()} sx={{ border: '2px dashed #ccc', padding: '20px', textAlign: 'center', cursor: 'pointer', backgroundColor: isDragActive ? '#e0f7fa' : '#f9f9f9', marginBottom: '16px' }}>
        <input {...getInputProps()} />
        <Typography>{isDragActive ? "Drop the file here..." : "Drag & drop an Excel file here, or click to select one"}</Typography>
      </Box>
      {selectedFile && <Typography>Selected File: {selectedFile.name}</Typography>}
      {validationMessage && <Typography color="error">{validationMessage}</Typography>}
      <Button variant="contained" color="secondary" onClick={handleUpload} disabled={!selectedFile}>Upload File</Button>
      <Button variant="contained" color="primary" onClick={handleDownload}>Download File</Button>
    </div>
  );
};

export default FileUpload;