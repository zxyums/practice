
Here’s a full implementation of the CustomSelectField component that adds optional onChange functionality without breaking the existing code. This ensures backward compatibility by using the default field.onChange behavior when no custom onChange is provided.

Full Component Code

import React, { useEffect } from "react";
import {
  FormHelperText,
  InputAdornment,
  MenuItem,
  Select,
  Tooltip,
} from "@mui/material";
import { FieldConfig } from "../types/formTypes";
import CustomLabel from "./CustomLabel";
import { useController, useFormContext } from "react-hook-form";
import _ from "lodash";
import { ArrowDropDownIcon } from "@mui/icons-material";

type Props = {
  control: any;
  config: FieldConfig;
  onChange?: (
    event: React.ChangeEvent<{ value: unknown }>,
    value: any
  ) => void; // Optional custom onChange
};

const CustomSelectField: React.FC<Props> = ({ control, config, onChange }) => {
  const { register, clearErrors } = useFormContext();
  const { fieldState, field } = useController({
    control,
    name: config.name,
    defaultValue: config.defaultValue || null,
    rules: {
      required: config.required
        ? `${config.label} is required`
        : false,
    },
  });

  const { error } = fieldState;

  // Handle custom and default onChange logic
  const handleOnChange = (event: React.ChangeEvent<{ value: unknown }>) => {
    const selectedValue = event.target.value;
    if (onChange) {
      onChange(event, selectedValue); // Call the custom onChange if provided
    }
    field.onChange(selectedValue); // Default onChange behavior
  };

  useEffect(() => {
    if (field.value) {
      clearErrors(config.name);
    }
  }, [clearErrors, config.name, field.value]);

  const options = _.orderBy(config.options, ["value"], ["asc"]);

  return (
    <div className="flexing">
      <CustomLabel htmlFor={config.name} label={config.label} />
      <Select
        id={config.name}
        value={field.value || ""}
        {...register(config.name)}
        onChange={handleOnChange} // Use the combined onChange handler
        onBlur={field.onBlur}
        displayEmpty
        renderValue={(selected: string) =>
          selected === undefined || selected === null ? (
            <span style={{ color: "#999" }}>Select</span>
          ) : (
            config.options.find(
              (data) => data.key === selected || data.value === selected
            )?.label || selected
          )
        }
        IconComponent={ArrowDropDownIcon}
        inputProps={{
          "data-testid": "custom_select",
          "aria-controls": config.name,
          "aria-label": config.label,
        }}
        style={{ minWidth: 200 }}
      >
        <MenuItem value={undefined} disabled>
          Select
        </MenuItem>
        {options.map((option) => (
          <MenuItem key={option.key} value={option.value}>
            {option.label}
          </MenuItem>
        ))}
      </Select>
      {error && (
        <FormHelperText style={{ color: "#D32F2F" }}>
          {error?.message || config.helperText || ""}
        </FormHelperText>
      )}
    </div>
  );
};

export default CustomSelectField;

Key Features:

	1.	Optional onChange:
	•	If onChange is passed as a prop, it is executed alongside the default field.onChange.
	•	If onChange is not provided, the default behavior remains unchanged.
	2.	Backward Compatible:
	•	Existing functionality is preserved. The component works the same as before if no custom onChange is passed.
	3.	Custom Label and Accessibility:
	•	Supports a CustomLabel for consistent styling.
	•	Provides aria-label and other accessibility features.
	4.	Dynamic Options:
	•	Dropdown options are sorted dynamically using lodash.
	5.	Error Handling:
	•	Displays error messages if validation fails.

Usage Example

Default Behavior (No Custom onChange):

<CustomSelectField
  control={control}
  config={{
    name: "example",
    label: "Example Dropdown",
    options: [
      { key: 1, value: "one", label: "One" },
      { key: 2, value: "two", label: "Two" },
    ],
    required: true,
  }}
/>

With Custom onChange:

<CustomSelectField
  control={control}
  config={{
    name: "example",
    label: "Example Dropdown",
    options: [
      { key: 1, value: "one", label: "One" },
      { key: 2, value: "two", label: "Two" },
    ],
    required: true,
  }}
  onChange={(event, value) => {
    console.log("Custom onChange Triggered:", value);
  }}
/>

This approach ensures flexibility while keeping the code simple and extensible.