import React from "react";
import { useForm, useWatch } from "react-hook-form";

const MyForm = () => {
  const { register, getValues, control } = useForm();

  // Define sections with required fields and conditions
  const sections = [
    {
      name: "Section 1",
      fields: [
        { name: "dropdown1", type: "dropdown", options: ["optionA", "optionB", "optionC"], condition: () => true },
        { name: "field1", type: "input", placeholder: "Field 1", condition: () => true },
      ],
    },
    {
      name: "Section 2",
      fields: [
        { name: "dropdown2", type: "dropdown", options: ["optionX", "optionY"], condition: (values) => values.dropdown1 === "optionA" },
        { name: "field2", type: "input", placeholder: "Field 2", condition: (values) => values.dropdown2 === "optionX" },
      ],
    },
    {
      name: "Section 3",
      fields: [
        { name: "dropdown3", type: "dropdown", options: ["optionY", "optionZ"], condition: (values) => values.dropdown1 === "optionB" },
        { name: "field3", type: "input", placeholder: "Field 3", condition: (values) => values.dropdown3 === "optionY" },
      ],
    },
  ];

  // Watch specific fields to dynamically update progress
  const watchedValues = useWatch({ control });

  // Filter required fields dynamically
  const getActiveFields = () => {
    const values = getValues();
    return sections.flatMap((section) =>
      section.fields.filter((field) => field.condition(values))
    );
  };

  // Calculate overall progress dynamically
  const calculateProgress = () => {
    const activeFields = getActiveFields();
    const filledFields = activeFields.filter((field) => getValues()[field.name]?.trim()).length;

    return activeFields.length ? Math.round((filledFields / activeFields.length) * 100) : 100;
  };

  // Check if a section is complete dynamically
  const isSectionComplete = (section) => {
    const activeFields = section.fields.filter((field) => field.condition(getValues()));
    const filledFields = activeFields.filter((field) => getValues()[field.name]?.trim()).length;

    return activeFields.length > 0 && filledFields === activeFields.length;
  };

  return (
    <form>
      {sections.map((section, index) => (
        <div key={index} style={{ marginBottom: "20px", border: "1px solid #ccc", padding: "10px" }}>
          <h3>{section.name}</h3>
          {section.fields.map((field) =>
            field.condition(watchedValues) ? (
              field.type === "dropdown" ? (
                <select key={field.name} {...register(field.name)} defaultValue="">
                  <option value="">Select {field.name}</option>
                  {field.options.map((option) => (
                    <option key={option} value={option}>
                      {option}
                    </option>
                  ))}
                </select>
              ) : (
                <input
                  key={field.name}
                  {...register(field.name)}
                  placeholder={field.placeholder}
                />
              )
            ) : null
          )}
          <p>Status: {isSectionComplete(section) ? "Complete" : "Incomplete"}</p>
        </div>
      ))}
      <div style={{ marginTop: "20px" }}>
        <h4>Overall Progress: {calculateProgress()}%</h4>
      </div>
    </form>
  );
};

export default MyForm;